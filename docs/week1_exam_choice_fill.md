# C++ 选择题 + 填空题综合评估卷（考点覆盖尽可能广）
建议用时：**150 分钟**  
满分：**100 分**  
说明：本卷**全部为选择题与填空题**。选择题包含单选与多选；多选题少选/错选均不得分。默认标准：C++11/14/17 基础能力（以面试常问为主）。

---

## 一、单选题（30 题 × 2 分 = 60 分）

1. 下列哪种声明表示“指向 `const int` 的指针”？  
A. `int* const p`  
B. `const int* p`  
C. `int& p`  
D. `const int& p`

2. 下列哪一项**不能**作为函数重载区分条件？  
A. 参数个数  
B. 参数类型  
C. 返回值类型  
D. 参数的 `const`（成员函数）

3. `int x{3.14};` 在 C++11 中：  
A. 正常编译，结果为 3  
B. 正常编译，结果为 4  
C. 触发窄化，编译期报错  
D. 运行时报错

4. 关于引用，正确的是：  
A. 引用可以重新绑定到另一个对象  
B. 引用可以为空（类似空指针）  
C. 引用必须初始化  
D. 引用一定分配独立内存

5. 下面哪条语句一定会调用**拷贝构造**（不考虑 NRVO/编译器优化）？  
A. `T a; T b(a);`  
B. `T a; T b; b = a;`  
C. `T a; T& r = a;`  
D. `T a; T* p = &a;`

6. 关于拷贝赋值 `operator=`，正确的是：  
A. 在对象首次创建时被调用  
B. 必须返回 `void`  
C. 自赋值不需要处理  
D. 一般返回 `T&`

7. 若类管理堆内存资源，且自定义了析构函数，通常还需要考虑：  
A. 拷贝构造与拷贝赋值  
B. 仅 `operator new`  
C. 仅 `operator delete`  
D. 仅默认构造

8. `new T[10]` 释放时应使用：  
A. `delete p`  
B. `delete[] p`  
C. `free(p)`  
D. 不需要释放

9. 关于 `nullptr`，正确的是：  
A. 它是 `int` 类型常量  
B. 它能隐式转换为任意整型  
C. 它的类型是 `std::nullptr_t`  
D. 它与 `NULL` 完全等价

10. 以下哪个操作最可能导致**未定义行为（UB）**？  
A. 访问 `std::vector` 的 `front()`  
B. 对空 `std::vector` 调用 `front()`  
C. 对 `std::vector` 调用 `size()`  
D. 对 `std::vector` 调用 `empty()`

11. `std::vector<int> v; v.reserve(100);` 的效果是：  
A. `v.size()` 变为 100  
B. `v.capacity()` 至少变为 100  
C. `v` 填充 100 个 0  
D. 释放多余容量

12. `std::vector<int> v(10);` 构造后：  
A. `size()==0`  
B. `size()==10`，元素未初始化  
C. `size()==10`，元素值为 0  
D. `capacity()==0`

13. 下列关于 `std::string::c_str()`，正确的是：  
A. 返回可写的字符数组指针  
B. 返回以 `\0` 结尾的只读字符序列指针  
C. 返回 `std::string` 内部拷贝的新内存  
D. 返回值在任何修改 `string` 后依旧长期有效

14. 关于 `const` 成员函数，正确的是：  
A. 不能访问任何成员  
B. 不能修改任何成员（包括 `mutable`）  
C. 可以重载出 `const` 与非 `const` 两个版本  
D. 不影响 `this` 的类型

15. 下列哪项描述了 `mutable` 的用途？  
A. 让对象可移动  
B. 让成员在 `const` 成员函数中也可被修改  
C. 让成员成为静态成员  
D. 让成员成为线程局部变量

16. 关于 `static` 局部变量，正确的是：  
A. 每次进入函数都会重新构造  
B. 生命周期贯穿整个程序运行期  
C. 只能存储 POD 类型  
D. 作用域是全局

17. `extern` 通常用于：  
A. 声明模板实例  
B. 声明具有外部链接的变量/函数  
C. 声明静态变量  
D. 声明匿名命名空间

18. 下面哪个属于**内部链接（internal linkage）**的典型手段？  
A. `extern int g;`  
B. `static int g;`（文件作用域）  
C. `int g;`  
D. `namespace std {}`

19. 关于头文件防重包含，正确的是：  
A. `#pragma once` 是 C++ 标准的一部分  
B. include guard 依赖宏实现  
C. include guard 会导致链接错误  
D. 防重包含只能用 `#pragma once`

20. 关于虚函数与多态，正确的是：  
A. 只有函数名相同就会动态绑定  
B. 通过基类指针/引用调用虚函数才会动态绑定  
C. 虚函数不能有实现  
D. 虚函数会导致对象无法放在栈上

21. 多态基类的析构函数通常要声明为 `virtual` 的原因是：  
A. 提升性能  
B. 允许对象切片  
C. 通过基类指针删除派生对象时保证派生析构被调用  
D. 让拷贝构造变成虚函数

22. 关于纯虚函数 `virtual void f() = 0;`，正确的是：  
A. 纯虚函数不能有定义  
B. 有纯虚函数的类一定不能定义对象  
C. 含纯虚函数的类通常是抽象类  
D. 派生类不需要实现纯虚函数

23. 下列哪项最准确描述“对象切片（slicing）”？  
A. 指针指向被释放对象  
B. 派生类对象按值赋给基类对象导致派生部分丢失  
C. vector 扩容导致元素搬迁  
D. 多线程访问同一对象

24. 关于异常与析构，正确的是：  
A. 析构函数抛异常最安全  
B. 若异常传播过程中析构再抛异常会触发 `std::terminate`  
C. 只有构造函数能抛异常  
D. 异常会自动释放所有 `new` 得到的对象

25. RAII 的核心是：  
A. 用宏管理资源  
B. 资源获取与对象生命周期绑定，析构自动释放  
C. 使用 `malloc/free`  
D. 禁止使用异常

26. `std::unique_ptr<T>` 的特性是：  
A. 可拷贝  
B. 引用计数共享所有权  
C. 独占所有权，通常只可移动  
D. 必须手动 delete

27. `std::shared_ptr<T>` 的典型风险是：  
A. 不能管理堆内存  
B. 循环引用导致内存泄漏  
C. 不能自定义删除器  
D. 不能用于多线程

28. 解决 `shared_ptr` 循环引用的常用工具是：  
A. `std::unique_ptr`  
B. `std::weak_ptr`  
C. `std::auto_ptr`  
D. `std::scoped_ptr`

29. 关于 `std::move`，正确的是：  
A. 一定发生内存拷贝  
B. 把对象变成 `const`  
C. 只是一次类型转换（将表达式转换为右值引用）  
D. 会立即清空源对象

30. 关于 `std::vector` 扩容时迭代器/引用，正确的是：  
A. 永远不会失效  
B. 只要 `size()` 不变就不会失效  
C. 发生重新分配时，指向元素的指针/引用/迭代器可能全部失效  
D. 只有 `end()` 会失效

---

## 二、多选题（10 题 × 2 分 = 20 分）

1. 下列哪些属于未定义行为（UB）的常见来源？  
A. 越界访问数组  
B. 读取未初始化的局部变量  
C. 解引用空指针  
D. 对同一指针重复 `delete`  
E. 访问已析构对象

2. 下列哪些说法正确？（关于 `const`）  
A. `const int* p`：`*p` 不可修改  
B. `int* const p`：`p` 不可指向别处  
C. `const int& r` 不能绑定到临时对象  
D. `const` 可以用于重载区分（成员函数）  
E. 顶层 const 与底层 const 含义不同

3. 关于 `std::vector`，正确的是：  
A. `reserve(n)` 不改变 `size()`  
B. `resize(n)` 会改变 `size()`  
C. 扩容一定按 2 倍增长（标准保证）  
D. 扩容可能触发元素移动/拷贝  
E. `operator[]` 会做越界检查

4. 关于异常安全的“强保证”，正确的是：  
A. 操作失败时对象状态保持不变  
B. 操作失败时对象仍可用但状态可能改变  
C. copy-and-swap 常用于实现强保证  
D. 强保证通常更难实现  
E. 强保证意味着一定不抛异常

5. 关于多态与虚函数，正确的是：  
A. `override` 能帮助编译器检查是否真正覆盖了虚函数  
B. 基类析构应尽量 `virtual`（用于多态删除）  
C. 通过对象按值调用虚函数也会动态绑定  
D. 虚函数调用依赖 vtable/vptr 的实现  
E. 构造函数可以是虚函数

6. 关于智能指针，正确的是：  
A. `unique_ptr` 可以自定义删除器  
B. `shared_ptr` 引用计数本身通常是线程安全更新的  
C. `weak_ptr::lock()` 可能返回空  
D. `shared_ptr` 循环引用需要设计规避  
E. 智能指针能自动解决所有资源管理问题

7. 关于移动语义，正确的是：  
A. 移动构造通常应标记 `noexcept`（有助于容器优化）  
B. 移动后对象必须处于可析构的有效状态  
C. 移动一定比拷贝快  
D. 右值引用本质是“将亡值”的绑定机制  
E. `std::move` 会执行移动构造

8. 关于编译与链接，正确的是：  
A. 头文件里定义非 `inline` 的函数会导致 ODR 风险  
B. `static` 文件作用域变量可避免多翻译单元重定义冲突  
C. `extern` 声明会分配存储  
D. 模板通常需要定义放在头文件可见  
E. include guard 影响运行时性能

9. 关于并发与数据竞争，正确的是：  
A. 数据竞争是未定义行为  
B. `volatile` 可用于线程同步  
C. `std::atomic` 可用于无锁计数器  
D. `mutex` 能用于互斥保护临界区  
E. 只要读操作就不会数据竞争

10. 下列哪些属于常见的“性能坑/工程坑”？  
A. 频繁小对象 `new/delete`  
B. `std::vector` 不 `reserve` 导致多次扩容搬迁  
C. 在热路径中频繁抛异常  
D. 误用 `shared_ptr` 形成共享所有权泛滥  
E. 在多线程中共享写同一 cache line（伪共享）

---

## 三、填空题（20 空 × 1 分 = 20 分）

1. `nullptr` 的类型是 ________。
2. `new T[n]` 对应的释放方式是 ________。
3. 多态基类通常需要将析构函数声明为 ________。
4. `std::vector` 的 `size()` 表示 ________，`capacity()` 表示 ________。
5. `reserve(n)` 的作用是 ________（一句话）。
6. `resize(n)` 的作用是 ________（一句话）。
7. 头文件防重复包含的两种常见方式是 `#pragma once` 和 ________。
8. 访问越界数组属于 ________ 行为（UB/IB/实现定义/未指定）。
9. RAII 的核心思想是：把资源的获取与释放绑定到对象的 ________。
10. `std::move(x)` 的本质是对 `x` 做一次 ________。
11. `unique_ptr` 的所有权模型是 ________。
12. `shared_ptr` 的常见风险是形成 ________ 引用导致泄漏。
13. 使用 ________ 可以打破 `shared_ptr` 循环引用。
14. `const int* p` 中 `const` 约束的是 ________（p / *p）。
15. `int* const p` 中 `const` 约束的是 ________（p / *p）。
16. 函数返回局部变量的引用会产生 ________（风险名词）。
17. `std::string::c_str()` 返回的 C 字符串以字符 ________ 结尾。
18. 在 `vector` 发生重新分配后，原有迭代器通常会 ________（有效/失效）。
19. 违反 ODR（One Definition Rule）常见表现是链接阶段出现 ________ 错误。
20. 数据竞争（data race）在 C++ 内存模型下属于 ________ 行为。

---

# 结束语
你做完以后：
- 把单选/多选的答案以题号形式发我（例如：单选 1B 2C...；多选 1ABDE...）
- 填空按题号给出

我会按面试官视角帮你：
- 给分
- 指出薄弱模块
- 补充常见追问与“口述模板答案”
