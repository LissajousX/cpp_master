# C++ 基础面试评估试卷（第一周范围）  
建议用时：**120 分钟**  
满分：**100 分**  
说明：请**独立闭卷**完成；编程题可选择你熟悉的编译器标准（建议 `-std=c++17`），但题目以 C++11/14 基础能力为主。

---

## 一、单选题（10 题 × 2 分 = 20 分）

1. 下列关于 `const` 的说法，正确的是：  
A. `const int* p` 表示指针本身不可修改  
B. `int* const p` 表示指针指向的内容不可修改  
C. `const int* p` 表示 `*p` 不可修改  
D. `const` 对函数返回值没有任何影响

2. 下列哪种初始化会触发**窄化（narrowing）**并在 C++11 的列表初始化中报错：  
A. `int x = 3.14;`  
B. `int x{3.14};`  
C. `double x{3.14};`  
D. `auto x = 3.14;`

3. 关于引用和指针，正确的是：  
A. 引用可以为空，指针不可以  
B. 引用一旦绑定不可再引用其他对象  
C. 引用本质上就是一个可变的指针  
D. 引用可以进行算术运算（如 `ref++` 改变绑定对象）

4. 下列哪一个析构函数声明是正确的（用于多态基类）：  
A. `~Base();`  
B. `virtual ~Base();`  
C. `static ~Base();`  
D. `inline virtual ~Base() = 0;`（纯虚析构无需定义）

5. `new`/`delete` 与 `malloc`/`free` 的主要区别不包括：  
A. `new` 会调用构造函数，`delete` 会调用析构函数  
B. `malloc/free` 只负责原始内存分配/释放  
C. `new` 返回 `void*`，`malloc` 返回具体类型指针  
D. `new/delete` 可能触发异常，`malloc` 返回 `nullptr`

6. 下列关于函数重载的说法，正确的是：  
A. 仅返回值不同可以构成重载  
B. 参数个数或参数类型不同可以构成重载  
C. `const` 不会影响成员函数签名  
D. 默认参数与重载无关，永远不会产生歧义

7. `std::vector<int> v; v.reserve(100);` 的效果是：  
A. `v.size()` 变为 100  
B. 为 100 个元素进行初始化  
C. 提前分配至少可容纳 100 个元素的容量，但不改变 `size()`  
D. 等价于 `resize(100)`

8. 以下哪种写法会产生**悬空引用/悬空指针**风险：  
A. 返回局部变量的引用  
B. 返回堆对象指针  
C. 返回静态变量引用  
D. 返回全局变量指针

9. 关于拷贝构造与拷贝赋值，正确的是：  
A. 拷贝赋值在对象构造时调用  
B. 拷贝构造可能由传值参数触发  
C. 两者都不会涉及资源管理  
D. 只要写了析构就不需要写拷贝构造/赋值

10. 关于 `unique_ptr`，正确的是：  
A. 可拷贝、可赋值  
B. 只能移动，不可拷贝  
C. 必须手动 `delete` 管理对象  
D. 与 `shared_ptr` 一样存在引用计数

---

## 二、多选题（5 题 × 3 分 = 15 分）

1. 下列哪些会导致**未定义行为（UB）**：  
A. `delete` 一个非 `new` 得到的指针  
B. 访问越界数组元素  
C. 解引用空指针  
D. `std::vector` 扩容后继续使用旧迭代器  
E. 读取未初始化的局部变量值

2. 关于 `static`，正确的有：  
A. 函数内 `static` 变量生命周期贯穿程序运行期  
B. 类的 `static` 成员变量属于对象而非类  
C. `static` 成员函数没有 `this` 指针  
D. 文件作用域 `static` 具有内部链接属性  
E. `static` 可以修饰构造函数

3. 关于 `const` 成员函数，正确的有：  
A. 其 `this` 类型为 `T* const`  
B. 其 `this` 类型为 `const T*`  
C. `const` 成员函数中不能修改任何成员变量  
D. 可以修改 `mutable` 成员  
E. `const` 影响重载区分（可与非 const 版本共存）

4. 下列关于异常的说法正确的有：  
A. 构造函数抛异常时，已构造完成的成员会逆序析构  
B. 析构函数应尽量 `noexcept`，避免异常传播导致 `std::terminate`  
C. 异常会自动释放所有 `new` 出来的对象  
D. RAII 能提升异常安全性  
E. `catch(...)` 能捕获所有异常类型

5. 下列属于“Rule of 5 / Rule of 3”相关成员的有：  
A. 析构函数  
B. 拷贝构造  
C. 拷贝赋值  
D. 移动构造  
E. 移动赋值

---

## 三、填空题（10 空 × 1.5 分 = 15 分）

1. C++ 中对象的存储期常见有：自动存储期、静态存储期、动态存储期、__________ 存储期。  
2. `std::vector` 扩容通常会导致元素被 ________ 或 ________ 到新内存。  
3. 头文件防止重复包含的常见方式有 `#pragma once` 与 ________。  
4. `nullptr` 的类型是 ________。  
5. `extern` 常用于声明 ________（链接属性相关）。  
6. 函数返回局部变量引用会导致 ________（风险）。  
7. 多态删除基类指针指向的派生对象时，基类析构函数必须是 ________。  
8. `std::string s; s.c_str()` 返回的是指向以 ________ 结尾字符数组的指针。  
9. `shared_ptr` 可能产生循环引用导致内存泄漏，可用 ________ 解决。  
10. 当你写 `const int* const p` 时，`p` 表示“__________、__________”。

---

## 四、简答题（5 题 × 6 分 = 30 分）

1. 解释“值语义 vs 引用语义”。在工程里什么时候更倾向用值语义（如 `std::string` / `std::vector`），什么时候更倾向引用语义（如共享对象、接口多态）？  

2. 解释 C++ 中“浅拷贝”和“深拷贝”的区别，并说明：  
- **默认拷贝**对含裸指针资源的类有什么风险？  
- 如何用 Rule of 3/5/0 避免问题？  

3. `std::vector` 的 `size()` 与 `capacity()` 有何区别？`reserve()` 与 `resize()` 的区别是什么？分别适用什么场景？  

4. 解释 RAII 的核心思想，并结合“异常安全”说明为什么 RAII 是 C++ 工程的关键原则。至少举 2 个例子（文件句柄、锁、内存、网络连接等）。  

5. 解释“多态”的实现条件（至少包含虚函数表/动态绑定的概念），并说明：  
- 为什么基类析构要 `virtual`？  
- 纯虚函数与抽象类是什么关系？

---

## 五、编程与代码阅读题（2 题 × 10 分 = 20 分）

### 题 1：代码阅读与 Bug 定位（10 分）
阅读以下代码，回答问题（无需运行）：

```cpp
#include <iostream>
#include <cstring>

class A {
public:
    A(const char* s) {
        data = new char[std::strlen(s) + 1];
        std::strcpy(data, s);
    }
    ~A() { delete data; } // 注意这里
    A(const A& other) { data = other.data; } // 注意这里
private:
    char* data;
};

int main() {
    A a("hello");
    A b = a;
    std::cout << "done\n";
}
```

要求：  
1. 指出至少 **2 个严重问题**并解释为什么（涉及未定义行为/双重释放等）。  
2. 给出**正确修复方向**（写出需要补充/修改哪些特殊成员函数，或改用什么资源管理方式）。  

---

### 题 2：实现一个小型 RAII（10 分）
实现一个 `FileGuard`：  
- 构造时接收文件路径与打开模式，内部持有 `FILE*`。  
- 析构时自动 `fclose`。  
- 禁止拷贝，允许移动。  
- 提供 `get()` 返回内部 `FILE*`。  

你可以用如下测试思路（不要求你提供 main，但实现需可用）：  
- 打开文件写入  
- 提前 `return`  
- 程序不泄漏资源

---

# 参考答案要点（建议你做完再看）

## 单选
1-C，2-B，3-B，4-B，5-C，6-B，7-C，8-A，9-B，10-B

## 填空（可能有同义答案）
1-线程（thread_local）  
2-拷贝 / 移动  
3-include guard（如 `#ifndef/#define/#endif`）  
4-`std::nullptr_t`  
5-外部变量或函数（外部链接的声明）  
6-悬空引用（dangling reference）  
7-虚函数（virtual）  
8-`\0`（空字符）  
9-`weak_ptr`  
10-指针本身不可变 / 指向的内容不可变

## 编程题要点提示
- 题1：  
  - `~A(){ delete data; }` 应为 `delete[] data;`  
  - 拷贝构造做了浅拷贝，导致双重释放；还缺拷贝赋值等  
  - 修复：实现 Rule of 3/5（深拷贝、正确释放、异常安全），或直接用 `std::string` / `std::unique_ptr<char[]>`  
- 题2：  
  - 成员：`FILE* fp_{nullptr};`  
  - 析构：`if(fp_) fclose(fp_);`  
  - 拷贝 ctor/赋值 `= delete`  
  - 移动 ctor/赋值：转移指针并将源置空

---

# 评分与面试通过建议

- **85-100 分**：基础扎实，能扛住大部分一面/二面基础追问  
- **70-84 分**：可面试，但需要补“资源管理/拷贝控制/容器语义/异常安全”  
- **<70 分**：建议回炉巩固（尤其是指针、对象生命周期、拷贝/析构、多态析构、vector 语义）

---

# 你接下来怎么用这份试卷（高效）
- **第一遍限时**做完，不看答案。  
- 把错题按类型归类：  
  - **对象模型/生命周期**  
  - **指针引用/const**  
  - **拷贝控制/资源管理**  
  - **STL 容器语义**  
  - **异常与 RAII**  
- 你把你的答案（尤其是简答题与两道代码题）贴出来，我可以按**面试官视角**给你逐条打分、补充追问点，并给“标准口述版”答案。

---

## 完成状态
已为你生成一份覆盖第一周 C++ 基础的**完整评估试卷 + 参考答案要点 + 评分建议**。你把作答结果发我后，我可以继续给你做面试级评估与纠偏。